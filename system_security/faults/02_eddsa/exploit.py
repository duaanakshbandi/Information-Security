#!/usr/bin/env python3

import subprocess
import os
import sys
import os.path
import filecmp

from Cryptodome.Util.number import inverse
from hashlib import sha512

q = 2**252 + 27742317777372353535851937790883648493

def H(a):
    return sha512(a).digest()
    
#converts a number in [0, q-1] to a byte-array representation
def ZtoBytes(z):
    return z.to_bytes(32, byteorder='little')

#converts a byte array back to a number in [0, q-1]
def bytesToZ(inbytes):
    m = int.from_bytes(inbytes, byteorder='little')
    return m % q

def getSig(message, fault=False):
    if fault:
        command = ['./simulator']
    else:
        command = ['./eddsa']
    command += [message]
    sigprog = subprocess.Popen(command, bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid)
    stdout, stderr = sigprog.communicate(timeout=300)
    outlen = 32*2*2 + len(message)*2
    sig = bytes.fromhex(stdout[:outlen].decode('utf-8'))
    R = sig[:32]
    s = sig[32:64]
    message = sig[64:]
    return (R, s, message)
    
def check_challenge(fname):
    fnames = fname+'_solution'
    if os.path.isfile(fnames) and os.access(fnames, os.R_OK):
        if (not os.path.isfile(fname)):
            print('Challenge failed!')
            return
        
        with open(fnames, 'rb') as f:
            s = bytesToZ(f.read())
        
        with open(fname, 'rb') as f:
            r = bytesToZ(f.read())
        
        if r == s:
            print('Challenge solved!')
        else:
            print('Challenge failed!')

def main():
    with open("key.pub", "rb") as f:
        pkbytes = f.read()
    
    #the recovered private key, stored as number mod q
    a = 0
    
########################################################################
# enter your code here

    # you can call the signature program by using getSig()
    #  the parameter "fault" controls if you run the program in the fault simulator or bare (without any faulting)
    inmessage = "This is a message that I want to sign"
    #(Rbytes, sbytes, outmessagebytes) = getSig(inmessage, fault=False) # no faulting

    # the above method returns byte arrays. For converting them to numbers mod q, use bytesToZ(). For the other direction, use ZtoBytes()
    #s = bytesToZ(sbytes)

    # the hash function SHA512, which is used in the signature scheme, is available via H()
    #shash = H(sbytes)

    # if you need to compute a modular inverse, simply call the included inverse()
    #sinverse = inverse(s, q)


    A = pkbytes

    # sign first message without a fault
    (first_Rbytes, first_sbytes, first_outmessagebytes) = getSig(inmessage, fault=False)  # no faulting

    HR1Am1 = H(first_Rbytes + A + first_outmessagebytes)
    R1 = bytesToZ(first_Rbytes)
    s1 = bytesToZ(first_sbytes)
    m1 = bytesToZ(first_outmessagebytes)

    # sign without a fault
    (second_Rbytes, second_sbytes, second_outmessagebytes) = getSig(inmessage, fault=True)  # with faulting

    HR2Am2 = H(second_Rbytes + A + second_outmessagebytes)
    R2 = bytesToZ(second_Rbytes)
    s2 = bytesToZ(second_sbytes)
    m2 = bytesToZ(second_outmessagebytes)

    r = ( bytesToZ(HR1Am1) * s2 - bytesToZ(HR2Am2) * s1) * inverse( s1 - s2 , q)
    a = s2 * inverse( r + bytesToZ(HR2Am2), q)
    a = a % q
########################################################################

    abytes = ZtoBytes(a)
    with open('a', 'wb') as f:
        f.write(abytes)
    
    check_challenge('a')

if __name__ == "__main__":
    sys.exit(main())
