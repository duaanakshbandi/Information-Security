#!/usr/bin/env python3
import math
import subprocess
import os
import sys
import os.path
import filecmp

import aes


def getPt(ct, fault=False):
    if fault:
        command = ['./simulator']
    else:
        command = ['./aes']
    command += [ct.hex()]
    sigprog = subprocess.Popen(command, bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid)
    stdout, stderr = sigprog.communicate(timeout=300)
    outlen = 16 * 2
    return bytes.fromhex(stdout[:outlen].decode('utf-8'))


# test if we have found the correct key by decrypting a random ct and testing the result
def check_challenge(k):
    randct = os.urandom(16)

    ptref = getPt(randct)
    dec = aes.AES(k)
    ptcheck = dec.decrypt_block(randct)

    if ptref == ptcheck:
        print('Challenge solved!')
    else:
        print('Challenge failed!')


def main():
    # fill this array with the recovered key
    k = bytearray(16)

    ########################################################################
    # enter your code here

    # you can query the AES decryption binary using the getPT function
    #  the "fault" parameter determines if you inject a fault in the execution
    ct = bytes.fromhex('00112233445566778899aabbccddeeff')
    real_pt = getPt(ct, False)
    faulty_pt = getPt(ct, True)

    print("real_pt:      ", real_pt)
    print("faulty_pt:    ", faulty_pt)

    ct1 = bytes.fromhex('aabbccddeeff778899aabb9cddeeff00')
    real_pt1 = getPt(ct1, False)
    faulty_pt1 = getPt(ct1, True)

    print("real_pt:      ", real_pt1)
    print("faulty_pt:    ", faulty_pt1)

    ct2 = bytes.fromhex('7892344bbbbbbbbbbbaabbccddeeff00')
    real_pt2 = getPt(ct2, False)
    faulty_pt2 = getPt(ct2, True)

    print("real_pt:      ", real_pt2)
    print("faulty_pt:    ", faulty_pt2)

    ct3 = bytes.fromhex('12345123451234512345123451234512')
    real_pt3 = getPt(ct3, False)
    faulty_pt3 = getPt(ct3, True)

    print("real_pt:      ", real_pt3)
    print("faulty_pt:    ", faulty_pt3)


    # k is a bytearray(16) which returns an array of bytes which is sequence of integers in the range 0 <= x < 256
    possible_values_k = list(range(0, 256))

    assert len(k) in aes.AES.rounds_by_key_size
    assert len(real_pt) == 16
    assert len(faulty_pt) == 16
    assert len(real_pt1) == 16
    assert len(faulty_pt1) == 16
    assert len(real_pt2) == 16
    assert len(faulty_pt2) == 16
    assert len(real_pt3) == 16
    assert len(faulty_pt3) == 16

    key_matrix = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]

    for i in range(16):
        for x in possible_values_k:

            key_matrix[ math.floor(i/4) ][ i % 4 ] = x

            plain_state_real = aes.bytes2matrix(real_pt)
            aes.add_round_key(plain_state_real, key_matrix)
            aes.sub_bytes(plain_state_real)

            plain_state_faulty = aes.bytes2matrix(faulty_pt)
            aes.add_round_key(plain_state_faulty, key_matrix)
            aes.sub_bytes(plain_state_faulty)

            plain_state_real1 = aes.bytes2matrix(real_pt1)
            aes.add_round_key(plain_state_real1, key_matrix)
            aes.sub_bytes(plain_state_real1)

            plain_state_faulty1 = aes.bytes2matrix(faulty_pt1)
            aes.add_round_key(plain_state_faulty1, key_matrix)
            aes.sub_bytes(plain_state_faulty1)

            plain_state_real2 = aes.bytes2matrix(real_pt2)
            aes.add_round_key(plain_state_real2, key_matrix)
            aes.sub_bytes(plain_state_real2)

            plain_state_faulty2 = aes.bytes2matrix(faulty_pt2)
            aes.add_round_key(plain_state_faulty2, key_matrix)
            aes.sub_bytes(plain_state_faulty2)

            plain_state_real3 = aes.bytes2matrix(real_pt3)
            aes.add_round_key(plain_state_real3, key_matrix)
            aes.sub_bytes(plain_state_real3)

            plain_state_faulty3 = aes.bytes2matrix(faulty_pt3)
            aes.add_round_key(plain_state_faulty3, key_matrix)
            aes.sub_bytes(plain_state_faulty3)

            diff = plain_state_real[math.floor(i/4)][i % 4] ^ plain_state_faulty[math.floor(i/4)][i % 4]
            diff1 = plain_state_real1[math.floor(i/4)][i % 4] ^ plain_state_faulty1[math.floor(i/4)][i % 4]
            diff2 = plain_state_real2[math.floor(i/4)][i % 4] ^ plain_state_faulty2[math.floor(i/4)][i % 4]
            diff3 = plain_state_real3[math.floor(i/4)][i % 4] ^ plain_state_faulty3[math.floor(i/4)][i % 4]

            if diff == diff1 and diff1 == diff2 and diff2 == diff3 and diff == 1:
                # here I check for diff == 1 because I always bitflip in index 0 ....
                print("diff: ", x, x.to_bytes(1, byteorder='big'), i)
                break;

            if x == 255:
                print("couldn't find key value at index ", i)

    print(key_matrix)

    keyyyy = b''
    for key_bytes in key_matrix:
        print(bytes(key_bytes))
        keyyyy += bytes(key_bytes)

    print(keyyyy)

    k = keyyyy

    # ...
    ########################################################################

    with open('key_rec', 'wb') as f:
        f.write(k)

    check_challenge(k)


if __name__ == "__main__":
    sys.exit(main())
